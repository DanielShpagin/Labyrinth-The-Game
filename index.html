<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

        <title>Labyrinth, The Game</title>

        <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
        <script src="https://assets.babylonjs.com/generated/Assets.js"></script>
        <script src="https://preview.babylonjs.com/ammo.js"></script>
        <script src="https://preview.babylonjs.com/cannon.js"></script>
        <script src="https://preview.babylonjs.com/Oimo.js"></script>
        <script src="https://preview.babylonjs.com/earcut.min.js"></script>
        <script src="https://preview.babylonjs.com/babylon.js"></script>
        <script src="https://preview.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
        <script src="https://preview.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
        <script src="https://preview.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
        <script src="https://preview.babylonjs.com/loaders/babylonjs.loaders.js"></script>
        <script src="https://preview.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
        <script src="https://preview.babylonjs.com/gui/babylon.gui.min.js"></script>
        <script src="https://preview.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>
        <script src='https://code.jquery.com/jquery-2.1.0.js'></script>

        <style>
            html,body{
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
                background-color: black;
                height: 100%;		
                margin: 0;
            }
            .whole{
                max-width: 1000pt;
                height: 100%;		
                margin: auto;
                background-color: black;
            }
            #box{
                position:relative;
            }
            #canvas{
                position:absolute;
                top:0;bottom:0;right:0;left:0;
                margin:auto;
                width: 100%;
                height: 100%;
                touch-action: none;
            }
            #win{
                color:#ffffff;
                font-family: "system-ui";
                font-size: 30px;
                position: absolute;
                top: 50%;
                left: 50%;
                margin-right: -50%;
                transform: translate(-50%, -50%);
            }
            .myButton {
                box-shadow:inset 0px 0px 0px 0px Gray;
                background:linear-gradient(to bottom, Gray 5%, Gray 100%);
                background-color:Gray;
                border-radius:3px;
                border:1px solid Gray;
                display:inline-block;
                cursor:pointer;
                color:#ffffff;
                font-family:Arial;
                font-size:30px;
                padding:25px 30px;
                text-decoration:none;
                text-shadow:0px 0px 0px Gray;
                margin: 5pt;
            }
            .myButton:active {
                position:relative;
                top:1px;
            }
        </style>
    </head>
<body>
    <div class="whole" style="display: grid; grid-template-rows: 80pt auto;">
        <div style="display: grid; grid-template-columns: 1fr auto auto 1fr;">
            <div></div>
            <a class="myButton" id="show">Show Shortest Way</a>
            <a class="myButton" id="refresh">Refresh â†º</a>
            <div></div>
        </div>
        <div id="box"><canvas id="canvas"></canvas></div>
    </div>
    <a id="win">You won, congratulations!</a>

    <script>
        var canvas = document.getElementById("canvas");

        var startRenderLoop = function (engine, canvas) {
            engine.runRenderLoop(function () {
                if (sceneToRender && sceneToRender.activeCamera) {
                    sceneToRender.render();
                }
            });
        }

        var engine = null;
        var scene = null;
        var sceneToRender = null;
        var shadowGenerator = null;

        var character = null;
        var foe = null;
        var xy = null;

        var div = 0.2;
        var labSize = 24;

        var enemies = [];
        var obj;

        var tap = false;
        var tap2 = false;
        var tap3 = false;

        //let startX;
        //let startY;

        var createDefaultEngine = function() { return new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true,  disableWebGL2Support: false}); };

        class Labyrinth {
            constructor(w, h) {
                this.width = w;
                this.height = h;
                this.cell = 1;

                this.labMassive = [];
                this.stack = [];
                this.shortPath = [];

                this.enterY = Math.floor(Math.random() * (this.width - 2)) + 1;
                this.exitY = Math.floor(Math.random() * (this.height - 2)) + 1;

                for (var i = 0; i < this.height*this.width; i++) {
                    this.labMassive.push(0);
                }
            }
            set(x,y,v) {
                if (x >= 0 && x < this.width && y >= 0 && y < this.height) {
                    this.labMassive[x+y*this.width]=v;
                }
            }
            get(x,y) {
                if (x >= 0 && x < this.width && y >= 0 && y < this.height) {
                    return this.labMassive[x+y*this.width];
                } else return 1;
            }
            makeEnterAndExit() {
                this.set(0, this.enterY, 0);
                this.set(this.width-1, this.exitY, 0);
            }
            makeEdge() {
                for (var i = 0; i < this.width; i++) {
                    this.set(i, 0, 1);
                }

                for (var i = 0; i < this.height; i++) {
                    this.set(0, i, 1);
                }

                for (var i = 0; i < this.width; i++) {
                    this.set(i, this.width-1, 1);
                }

                for (var i = 0; i <this.height; i++) {
                    this.set(this.height-1, i, 1);
                }
            }
            makeRandomSquares() {
                for (var i = 0; i < 10; i++) {
                    var randomX = Math.floor(Math.random() * (this.width - 4)) + 2;
                    var randomY = Math.floor(Math.random() * (this.height - 4)) + 2;

                    this.set(randomX, randomY, 1);
                }
            }
            generateObstacle() {
                for (var i = 0; i < 50000; i++) {
                    var n = 0;
                    this.randomX = Math.floor(Math.random() * (this.width - 2)) + 1;
                    this.randomY = Math.floor(Math.random() * (this.height - 2)) + 1;

                    if (this.get(this.randomX-1, this.randomY) !== 0) {
                        n++;
                        if (this.get(this.randomX+1, this.randomY-1) !== 0 || this.get(this.randomX+1, this.randomY+1) !== 0) {
                            n++;
                        }
                    }

                    if (this.get(this.randomX+1, this.randomY) !== 0) {
                        n++;
                        if (this.get(this.randomX-1, this.randomY+1) !== 0 || this.get(this.randomX-1, this.randomY-1) !== 0) {
                            n++;
                        }
                    }

                    if (this.get(this.randomX, this.randomY+1) !== 0) {
                        n++;
                        if (this.get(this.randomX-1, this.randomY-1) !== 0 || this.get(this.randomX+1, this.randomY-1) !== 0) {
                            n++;
                        }
                    }

                    if (this.get(this.randomX, this.randomY-1) !== 0) {
                        n++;
                        if (this.get(this.randomX-1, this.randomY+1) !== 0 || this.get(this.randomX+1, this.randomY+1) !== 0) {
                            n++;
                        }
                    }

                    if (n === 1) {
                        this.set(this.randomX, this.randomY, 1);
                    }
                }
            }
            clearLabyrinth() {
                for (var x = 0; x < this.width; x++) {
                    for (var y = 0; y < this.height; y++) {
                        if (this.get(x, y) >= 1000) this.set(x, y, 0);
                    }
                }
            }
            scanLabyrinth() {
                this.clearLabyrinth();

                xy = [0, this.enterY];
                var k = 1000;

                this.stack = [];
                this.stack.push(xy);

                this.set(xy[0], xy[1], k++);

                for (var i = 0; i < this.stack.length; i++) {
                    xy = this.stack[i];

                    if (this.get(xy[0]-1, xy[1]) === 0) {
                        this.stack.push([xy[0]-1, xy[1]]);
                        this.set(xy[0]-1, xy[1], k++);
                    }

                    if (this.get(xy[0]+1, xy[1]) === 0) {
                        this.stack.push([xy[0]+1, xy[1]]);
                        this.set(xy[0]+1, xy[1], k++);
                    }

                    if (this.get(xy[0], xy[1]+1) === 0) {
                        this.stack.push([xy[0], xy[1]+1]);
                        this.set(xy[0], xy[1]+1, k++);
                    }

                    if (this.get(xy[0], xy[1]-1) === 0) {
                        this.stack.push([xy[0], xy[1]-1]);
                        this.set(xy[0], xy[1]-1, k++);
                    }

                    if (xy[0] === this.width-1 && xy[1] === this.exitY) return true;
                }

                return false;   
            }
            findShortestPath() {
                xy = [this.width-1, this.exitY];
                var number = this.get(this.width-1, this.exitY);

                this.shortPath = [];
                this.shortPath.push(xy);

                for (var i = 0; i < this.stack.length; i++) {
                    xy = this.shortPath[i];

                    var x = xy[0];
                    var y = xy[1];

                    var left = this.get(x-1, y);
                    var right = this.get(x+1, y);
                    var down = this.get(x, y+1);
                    var up = this.get(x, y-1);

                    if (left >= 1000) {
                        if (number > left) {
                            number = left;
                            xy = [x-1, y];
                        }
                    }

                    if (right >= 1000) {
                        if (number > right) {
                            number = right;
                            xy = [x+1, y];
                        }
                    }

                    if (down >= 1000) {
                        if (number > down) {
                            number = down;
                            xy = [x, y+1];
                        }
                    }

                    if (up >= 1000) {
                        if (number > up) {
                            number = up;
                            xy = [x, y-1];
                        }
                    }

                    this.shortPath.push(xy);
                    if (xy[0] === 0 && xy[1] === this.enterY) break;
                }
            }
            makeLonger() {
                for (var d = 0; d < 20; d++) {
                    this.scanLabyrinth();
                    this.findShortestPath();

                    for (var i = 1; i < this.shortPath.length-1; i++) {
                        var x = this.shortPath[i][0];
                        var y = this.shortPath[i][1];

                        var up = this.get(x, y-1);
                        var down = this.get(x, y+1);

                        if (up < 1000 && up >= 1 && down < 1000 && down >= 1) {
                            this.set(x, y, 1);
                            if (!this.scanLabyrinth()) {
                                this.set(x, y, 0);
                            } else {
                                this.scanLabyrinth();
                                this.findShortestPath(); 
                                break;
                            }
                        }
                    }
                }
            }
            drawFlat() {
                for (var x = 0; x < this.height; x++) {
                    for (var y = 0; y < this.width; y++) {
                        var color = new BABYLON.Color3(0.5, 0.35, 0.73);
                        var faceColors = new Array(6);
                        faceColors.fill(color);
                        var box = BABYLON.MeshBuilder.CreateBox("box", {height: 0.1, faceColors});
                        box.position.x = x-this.width/2;
                        box.position.z = y-this.height/2;
                        box.position.y = -0.5;
                        //box.receiveShadows = true;
                        //shadowGenerator.getShadowMap().renderList.push(box);
                    }
                }
            }
            drawLabyrinth() {
                for (var i = 0; i < lab.height; i++) {
                    for (var j = 0; j < lab.width; j++) {
                        var c = lab.get(j, i);
                        if (c === 1) {
                            var color = new BABYLON.Color3(0.98, 1, 0);
                            var faceColors = new Array(6);
                            faceColors.fill(color);
                            var box = BABYLON.MeshBuilder.CreateBox("box", {faceColors});
                            box.position.x = i-this.width/2;
                            box.position.z = j-lab.height/2;
                            //box.receiveShadows = true;
                            //shadowGenerator.addShadowCaster(box);
                            //shadowGenerator.getShadowMap().renderList.push(box);
                        }
                    }
                }
            }
            drawShortPath() {
                for (var i = 0; i < this.shortPath.length; i++) {
                    var color = new BABYLON.Color3(0.04, 0.93, 0.11);
                    var faceColors = new Array(6);
                    faceColors.fill(color);
                    var box = BABYLON.MeshBuilder.CreateBox("box", {height: 0.1, faceColors});
                    box.position.x = this.shortPath[i][1]-this.width/2;
                    box.position.z = this.shortPath[i][0]-this.height/2;
                    box.position.y = -0.5;
                    //box.receiveShadows = true;
                    //shadowGenerator.addShadowCaster(box);
                    //shadowGenerator.getShadowMap().renderList.push(box);
                }
            }
            createScene() {
                var scene = new BABYLON.Scene(engine);
                scene.clearColor = new BABYLON.Color4(0, 0, 0, 0);

                const camera = new BABYLON.ArcRotateCamera("camera", 0, Math.PI / 8, 40, new BABYLON.Vector3(0, 0, 0));
                camera.attachControl(canvas, false);
                camera.inputs.attached.keyboard.detachControl();
                camera.detachControl(canvas);

                lab = lab.complexLabyrinth();

                xy = [0, lab.enterY];
                player = new Player(xy[0], xy[1]);

                var light = new BABYLON.DirectionalLight("dir01", new BABYLON.Vector3(-1, -2, -1), scene);
                light.position = new BABYLON.Vector3(20, 40, 20);
                light.intensity = 0.5;

                //shadowGenerator = new BABYLON.ShadowGenerator(2048, light);
                //shadowGenerator.useExponentialShadowMap = true;

                //shadowGenerator.useBlurCloseExponentialShadowMap = true;
                //shadowGenerator.forceBackFacesOnly = true;
                //shadowGenerator.blurKernel = 32;
                //shadowGenerator.useKernelBlur = true;
                //scene.shadowsEnabled = true;

                //light.shadowMinZ = 40;
                //light.shadowMaxZ = 100;

                this.drawFlat();
                this.drawLabyrinth();
                player.drawPlayer();

                return scene;
            }
            complexLabyrinth() {
                var best = new Labyrinth(labSize, labSize);
                for (var i = 0; i < 20; i++) {
                    var lab = new Labyrinth(labSize, labSize);

                    lab.makeEdge();
                    lab.makeEnterAndExit();
                    lab.makeRandomSquares();
                    lab.generateObstacle();
                    lab.makeLonger();

                    if (best.shortPath.length < lab.shortPath.length) {
                        best = lab;
                    }
                }
                return best;
            }
        }

        class Player {
            constructor(x, y) {
                this.x = x;
                this.y = y;
            }
            drawPlayer() {
                character = BABYLON.MeshBuilder.CreateSphere("character", {});

                character.position.x = this.y-lab.height/2;
                character.position.z = this.x-lab.width/2;
            }
        }

        class Enemy {
            constructor() {
                this.number = 0;

                this.dx = 0;
                this.dz = 0;

                this.sx = 0;
                this.sz = 0;

                this.halfX = 0.5;
                this.halfZ = 0.5;

                this.foe;
            }
            oneStep() {
                this.sx = this.foe.position.x;
                this.sz = this.foe.position.z;

                var x = Math.floor(this.sz+lab.width/2+0.5+this.dz*3);
                var y = Math.floor(this.sx+lab.height/2+0.5+this.dx*3);

                if (lab.get(x, y) === 1) {
                    this.generateCoords();
                } else {
                    this.foe.position.x += this.dx;
                    this.foe.position.z += this.dz;
                }
            }
            generateCoords() {
                var x = 0;
                var z = 0;

                do {
                    x = Math.floor(Math.random()*3)-1;
                    z = Math.floor(Math.random()*3)-1;

                    if ((x === 0 || z === 0) && (x !== 0 || z !== 0)) break;
                } while (true);

                this.dx = x*div;
                this.dz = z*div;
            }
            setPosition() {
                var rmin = 10000;
                var obj;
                const margin = 2;

                this.number++;

                do {
                    this.sx = Math.floor(Math.random() * (lab.width-margin*2))-lab.width/2+margin;
                    this.sz = Math.floor(Math.random() * (lab.height-margin*2))-lab.height/2+margin;

                    if (lab.get(this.sz+lab.width/2, this.sx+lab.height/2) === 0) break;
                } while (true);

                for (var i = 0; i < enemies.length; i++) {
                    obj = enemies[i];
                    var r = Math.sqrt((this.sx-obj.sx)*(this.sx-obj.sx)+(this.sz-obj.sz)*(this.sz-obj.sz));
                    if (r < rmin && obj !== this) {
                        rmin = r;
                    }
                }

                if (rmin >= 6 || this.number >= 10) {
                    this.foe.position.x = this.sx;
                    this.foe.position.z = this.sz;
                    console.log(rmin, this.sx, this.sz);
                } else this.setPosition();
            }
            drawEnemy() {
                var material = new BABYLON.StandardMaterial(scene);
                material.alpha = 1;
                material.diffuseColor = new BABYLON.Color3(1, 0, 0);
                this.foe = BABYLON.MeshBuilder.CreateSphere("foe", {});
                this.foe.material = material;

                this.setPosition();
            }
        }

        var lab = new Labyrinth(labSize, labSize);
        var player = new Player(0, lab.enterY);

        $('body').keydown(function (event) {
            var key = event.key;
            var keys = ["ArrowRight", "ArrowDown", "ArrowLeft", "ArrowUp"];
            var letters = ["d", "s", "a", "w"];
            xy = [[player.x+1, player.y], [player.x, player.y+1], [player.x-1, player.y], [player.x, player.y-1]];

            for (var i = 0; i < 4; i++) {
                if (key === keys[i] || key === letters[i]) {
                    if (lab.get(xy[i][0], xy[i][1]) === 0) {
                        player.x = xy[i][0];
                        player.y = xy[i][1];
                    }
                }
            }

            lab.clearLabyrinth();
        });
        $('#refresh').click(function () {
            scene.dispose();

            initFunction().then(() => {
                sceneToRender = scene;
            });
        });
        $('#show').click(function () {
            lab.drawShortPath();
        });

        setInterval(() => {
            if (character) {
                var cx = character.position.x;
                var cz = character.position.z;

                var dx = player.y-lab.height/2-cx;
                var dz = player.x-lab.width/2-cz;

                var x;
                var z;

                if (dz > div) dz = div;
                if (dz < -div) dz = -div;
                if (dx > div) dx = div;
                if (dx < -div) dx = -div;

                character.position.x += dx;
                character.position.z += dz;

                for (var i = 0; i < enemies.length; i++) {
                    obj = enemies[i];
                    x = obj.foe.position.x-cx;
                    z = obj.foe.position.z-cz;

                    if (Math.abs(x*x+z*z) <= div) {
                        character.position.x = lab.enterY-lab.width/2;
                        character.position.z = -lab.height/2;

                        player.x = 0;
                        player.y = lab.enterY;
                    }
                }

                if (cx === lab.exitY-lab.height/2 && cz === lab.width-1-lab.width/2) $('#win').show();
            }
        }, 30);

        setInterval(() => {
            if (enemies.length) {
                var obj1;
                var obj2;

                var x1;
                var z1;

                var x2;
                var z2;

                for (var i = 0; i < enemies.length; i++) {
                    obj = enemies[i];
                    obj.oneStep();
                    if (obj.dx === 0 && obj.dz === 0) obj.generateCoords();
                }

                for (var i = 0; i < enemies.length; i++) {
                    obj1 = enemies[i];
                    x1 = obj1.foe.position.x;
                    z1 = obj1.foe.position.z;

                    for (var j = 0; j < i; j++) {
                        if (i !== j) {
                            obj2 = enemies[j];
                            x2 = obj2.foe.position.x;
                            z2 = obj2.foe.position.z;

                            if ((x1-x2)*(x1-x2)+(z1-z2)*(z1-z2) <= 1) {
                                if ((x2-x1)*obj1.dx+(z2-z1)*obj1.dz > 0) {
                                    obj1.dx *= -1;
                                    obj1.dz *= -1;
                                }

                                if ((x1-x2)*obj2.dx+(z1-z2)*obj2.dz > 0) {
                                    obj2.dx *= -1;
                                    obj2.dz *= -1;
                                }
                            }
                        }
                    }
                }
            }
        }, 50);

        window.initFunction = async function() {
            var asyncEngineCreation = async function() {
                try {
                    return createDefaultEngine();
                } catch(e) {
                    return createDefaultEngine();
                }
            }

            if(!window.engine){
                window.engine = await asyncEngineCreation();
                startRenderLoop(engine, canvas);
            }
            if (!engine) throw 'engine should not be null.';

            window.scene = lab.createScene();

            enemies = [];

            for (var i = 0; i < 10; i++) {
                enemies.push(new Enemy());

                obj = enemies[i];
                obj.drawEnemy();
            }

            for (var i = 0; i < enemies.length; i++) {
                obj = enemies[i];
                obj.generateCoords();
            }

            scene.onPointerObservable.add((pointerInfo) => {
                switch (pointerInfo.type) {
                    case BABYLON.PointerEventTypes.POINTERDOWN:
                        tap = true;
                        console.log('down');
                        break;
                    case BABYLON.PointerEventTypes.POINTERUP:
                        tap = false;
                        console.log('up');
                        break;
                }

                if (tap) {
                    lab.clearLabyrinth();

                    var mx = pointerInfo.event.movementX;
                    var my = pointerInfo.event.movementY;

                    var cx = character.position.x;
                    var cz = character.position.z;

                    var dx = player.y-lab.height/2-cx;
                    var dz = player.x-lab.width/2-cz;

                    xy = [[player.x+1, player.y], [player.x-1, player.y], [player.x, player.y-1], [player.x, player.y+1]];

                    if (dx*dx+dz*dz <= div) {
                        if (Math.abs(mx) > Math.abs(my)) {
                            if (mx > 0) {
                                if (lab.get(xy[0][0], xy[0][1]) === 0) {
                                    player.x = xy[0][0];
                                    player.y = xy[0][1];
                                }
                            }

                            if (mx < 0) {
                                if (lab.get(xy[1][0], xy[1][1]) === 0) {
                                    player.x = xy[1][0];
                                    player.y = xy[1][1];
                                }
                            }
                        } else {
                            if (my < 0) {   
                                if (lab.get(xy[2][0], xy[2][1]) === 0) {
                                    player.x = xy[2][0];
                                    player.y = xy[2][1];
                                }
                            }

                            if (my > 0) {
                                if (lab.get(xy[3][0], xy[3][1]) === 0) {
                                    player.x = xy[3][0];
                                    player.y = xy[3][1];
                                }
                            }
                        }
                    }
                }
            });

            $('#win').hide();
        };
        initFunction().then(() => {
            sceneToRender = scene;               
        });

        window.addEventListener("resize", function () {
            engine.resize();
        });
    </script>
</body>
</html>